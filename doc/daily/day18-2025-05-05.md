# LeetCode 60 天挑戰 Day18 | Stack & Queue Part III

# 今日任務

- #239. Sliding Window Maximum
- #347. Top K Frequent Elements 
- Stack and Queue Summary

---

# 239. Sliding Window Maximum 重點整理

## 題目說明

- 給定一個整數陣列 `nums` 和一個整數 `k`，有一個大小為 `k` 的滑動視窗從陣列的最左側移動到最右側。你只能看到視窗中的 `k` 個元素。每次滑動視窗向右移動一位，返回所有滑動視窗中的最大值。
- 範例輸入：nums = [1,3,-1,-3,5,3,6,7], k = 3
- 對應輸出：[3,3,5,5,6,7]

## 解法一：PriorityQueue (大根堆)

### 思路
- 使用 `PriorityQueue<int[]>` 儲存元素與索引，並重寫比較器確保「最大值在堆頂」。
- 每次移動視窗時，將新元素加入堆，並持續移除超出視窗的元素（`index < i - k + 1`）。
- 堆頂的元素即為當前視窗最大值。

### 重點
- Java 的 `PriorityQueue` 是小根堆，需透過 `Comparator` 實現大根堆行為。
- 儲存 `int[] {值, index}` 是為了後續驗證元素是否過期（滑出視窗）。
- 每次加入與移除操作時間複雜度為 `O(log k)`。

### 複雜度分析
- 時間複雜度：`O(n log k)`，每個元素最多進出堆一次。
- 空間複雜度：`O(k)`，堆最多儲存 `k` 個元素。

## 解法二：單調隊列（Monotonic Queue） *推薦

### 思路
- 維護一個遞減單調隊列：新元素加入前，將尾部比它小的值全移除。
- 每次移動視窗時，若隊首元素已離開視窗，則移除。
- 隊首永遠是當前視窗內最大值。

### 重點
- 時間複雜度是線性的，因為每個元素最多進出隊列一次。
- 適合高效處理大量資料，面試推薦使用。

### 複雜度分析
- 時間複雜度：`O(n)`
- 空間複雜度：`O(k)`

## Java 程式碼連結

- [ID239SlidingWindowMaximum.java](../../src/main/java/io/github/monty/leetcode/stackqueue/ID239SlidingWindowMaximum.java)