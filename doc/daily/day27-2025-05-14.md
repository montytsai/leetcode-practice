# LeetCode 60 天挑戰 Day27 | Binary Tree Part VI

# 今日任務

- LC617. Merge Two Binary Trees
- LC700. Search in a Binary Search Tree
- LC98. Validate Binary Search Tree

---

# LC617. Merge Two Binary Trees

## 題目說明
給定兩棵二元樹 `root1` 與 `root2`，請合併它們為一棵新樹：

- 若兩個節點都存在，節點值相加作為新節點值。
- 若只有一個節點存在，則該節點直接作為新節點。

回傳合併後的新樹根節點。

---

## 解法：DFS 遞迴合併

### 思路
- 自頂向下遞迴合併兩棵樹。
- 若兩節點都為非空，則節點值相加，並遞迴左右子樹。
- 若任一節點為 null，直接回傳另一節點。

### 重點
- 修改的是 `root1` 節點，節省記憶體。
- 保持簡潔遞迴，處理 null 情況即可。

### 複雜度分析
- **時間複雜度**：O(n)，n 為節點總數，兩樹遍歷一次。
- **空間複雜度**：O(h)，h 為樹高，遞迴堆疊所需空間。

---

## Java 程式碼連結

- 題目實作：[ID617MergeTwoBinaryTrees.java](../../src/main/java/io/github/monty/leetcode/binarytree/ID617MergeTwoBinaryTrees.java)
- 單元測試：[ID617MergeTwoBinaryTreesTest.java](../../src/test/java/io/github/monty/leetcode/binarytree/ID617MergeTwoBinaryTreesTest.java)

---

# LC700. Search in a Binary Search Tree

## 題目說明
- 給定一棵二元搜尋樹 (BST) 的根節點 `root` 和一個整數 `val`
- 返回值等於 `val` 的節點所代表的子樹根節點；若找不到，則回傳 null

---

## 解法：迴圈搜尋（Iterative BST Traversal）

### 思路
- 根據 BST 性質：若目標值小於節點，往左子樹搜尋；大於則往右子樹
- 若等於則直接回傳該節點，代表已找到子樹根

### 重點
- 使用迴圈，節省 call stack

### 複雜度分析
- 時間複雜度：O(h)，h 為樹高，最壞為 O(n)
- 空間複雜度：O(1)

---

## 解法比較
| 解法        | 優點           | 缺點            | 適用情境         |
|-----------|--------------|---------------|--------------|
| 迴圈搜尋      | 節省空間，結構簡單    | 可讀性稍差，不支援回朔追蹤 | 非平衡樹、大型節點數   |
| 遞迴搜尋（未實作） | 可保留搜尋路徑，較易閱讀 | call stack 增加 | 體積小、偏重邏輯推演用途 |

---

## Java 程式碼連結
- 題目實作：[ID700SearchInABinarySearchTree.java](../../src/main/java/io/github/monty/leetcode/binarytree/ID700SearchInABinarySearchTree.java)
- 單元測試：[ID700SearchInABinarySearchTreeTest.java](../../src/test/java/io/github/monty/leetcode/binarytree/ID700SearchInABinarySearchTreeTest.java)
