# LeetCode 60 天挑戰 Day36 | Binary Tree Part X

# 今日任務

- LC669. Trim a Binary Search Tree
- LC108. Convert Sorted Array to Binary Search Tree
- LC538. Convert BST to Greater Tree

---

# LC669. Trim a Binary Search Tree

## 題目說明
- 給定一個 BST（Binary Search Tree）與範圍 `[low, high]`。
- 修剪這棵樹，使所有節點值都在這個範圍內。
- 修剪後仍需保持 BST 結構，節點相對位置不變。
- 根節點可能會改變。
- 確保唯一解。

---

## 解法一：DFS 遞迴

### 思路：
- 使用 BST 特性：若節點值小於 low，其左子樹都不合法；反之亦然。
- 採用後序處理方式：
    - 先處理左右子樹，再處理當前節點是否應保留。
- 每次遞迴都返回合法子樹的根節點。

### 重點：
- 若 `root.val < low`，直接丟棄左子樹，處理右子樹。
- 若 `root.val > high`，直接丟棄右子樹，處理左子樹。
- 只有當 `low <= root.val <= high` 時才保留當前節點。

### 複雜度分析：
- 時間：O(n)，每個節點最多遍歷一次。
- 空間：O(h)，h 為樹高（最壞 O(n)）。

---

## 解法二：BFS 迭代修剪根與左右子樹

### 思路：
- 先讓 root 移到範圍內（可能會調整根節點）。
- 然後沿著每個節點，若其子節點不合法則往下接替。

### 問題：(by chatGPT)
- `curr.left = curr.left.right` 等寫法會破壞原始結構。
- 無法保證所有子孫節點正確接上。

---

## 解法比較

| 解法        | 優點        | 缺點          |
|-----------|-----------|-------------|
| DFS 遞迴    | 結構清晰、語意直覺 | 遞迴深度依賴樹高    |
| 迭代處理根與子節點 | 無需棧空間     | 易破壞原 BST 結構 |

---

## Java 程式碼連結
- 題目實作：[ID669TrimABinarySearchTree.java](../../src/main/java/io/github/monty/leetcode/binarytree/ID669TrimABinarySearchTree.java)
- 單元測試：[ID669TrimABinarySearchTreeTest.java](../../src/test/java/io/github/monty/leetcode/binarytree/ID669TrimABinarySearchTreeTest.java)
