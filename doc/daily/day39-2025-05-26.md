# LeetCode 60 天挑戰 Day36 | Binary Tree Part X

# 今日任務

- LC669. Trim a Binary Search Tree
- LC108. Convert Sorted Array to Binary Search Tree
- LC538. Convert BST to Greater Tree

---

# LC669. Trim a Binary Search Tree

## 題目說明
- 給定一個 BST（Binary Search Tree）與範圍 `[low, high]`。
- 修剪這棵樹，使所有節點值都在這個範圍內。
- 修剪後仍需保持 BST 結構，節點相對位置不變。
- 根節點可能會改變。
- 確保唯一解。

---

## 解法一：DFS 遞迴

### 思路：
- 使用 BST 特性：若節點值小於 low，其左子樹都不合法；反之亦然。
- 採用後序處理方式：
    - 先處理左右子樹，再處理當前節點是否應保留。
- 每次遞迴都返回合法子樹的根節點。

### 重點：
- 若 `root.val < low`，直接丟棄左子樹，處理右子樹。
- 若 `root.val > high`，直接丟棄右子樹，處理左子樹。
- 只有當 `low <= root.val <= high` 時才保留當前節點。

### 複雜度分析：
- 時間：O(n)，每個節點最多遍歷一次。
- 空間：O(h)，h 為樹高（最壞 O(n)）。

---

## 解法二：BFS 迭代修剪根與左右子樹

### 思路：
- 先讓 root 移到範圍內（可能會調整根節點）。
- 然後沿著每個節點，若其子節點不合法則往下接替。

### 問題：(by chatGPT)
- `curr.left = curr.left.right` 等寫法會破壞原始結構。
- 無法保證所有子孫節點正確接上。

---

## 解法比較

| 解法        | 優點        | 缺點          |
|-----------|-----------|-------------|
| DFS 遞迴    | 結構清晰、語意直覺 | 遞迴深度依賴樹高    |
| 迭代處理根與子節點 | 無需棧空間     | 易破壞原 BST 結構 |

---

## Java 程式碼連結
- 題目實作：[ID669TrimABinarySearchTree.java](../../src/main/java/io/github/monty/leetcode/binarytree/ID669TrimABinarySearchTree.java)
- 單元測試：[ID669TrimABinarySearchTreeTest.java](../../src/test/java/io/github/monty/leetcode/binarytree/ID669TrimABinarySearchTreeTest.java)

---

# LC108. Convert Sorted Array to Binary Search Tree

## 題目說明
- 給定一個**遞增排序**的整數陣列 `nums`
- 請將其轉換為一棵**高度平衡的二元搜尋樹（BST）**
  - 高度平衡：每個節點的左右子樹高度差最多為 1

---

## 解法：Divide & Conquer（遞迴建樹）

### 思路
- 每次取陣列中間元素作為根節點
- 左半段遞迴建立左子樹、右半段遞迴建立右子樹
- 遞迴直到子區間為空

### 重點：
- 中間元素作為根，天然保證平衡
- 為了平衡，可選 `(start + end) / 2` 或 `(start + end + 1) / 2` 作為根，效果相近

### 複雜度分析
- 時間：O(n)，每個元素都造訪一次
- 空間：O(log n)，遞迴堆疊深度（平均）；最壞為 O(n)

---

## Java 程式碼連結
- 題目實作：[ID108ConvertSortedArrayToBinarySearchTree.java](../../src/main/java/io/github/monty/leetcode/binarytree/ID108ConvertSortedArrayToBinarySearchTree.java)
- 單元測試：[ID108ConvertSortedArrayToBinarySearchTreeTest.java](../../src/test/java/io/github/monty/leetcode/binarytree/ID108ConvertSortedArrayToBinarySearchTreeTest.java)

