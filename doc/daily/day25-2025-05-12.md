# LeetCode 60 天挑戰 Day23 | Binary Tree Part III

# 今日任務

- LC110. Balanced Binary Tree
- LC257. Binary Tree Paths
- LC404. Sum of Left Leaves

---

# 🌲 二元樹的深度與高度筆記

## 📘 一、基本定義（學術觀點）

| 概念     | 定義                                   | 路徑單位        | 常見用途      |
|--------|--------------------------------------|-------------|-----------|
| **深度** | 從根節點（root）到某節點的**最長簡單路徑長度**          | 邊數（有時也用節點數） | 往下走（自上而下） |
| **高度** | 從某節點到最遠葉節點的**最長簡單路徑長度**（leaf = 無左右子） | 邊數（或節點數）    | 往上走（自下而上） |

- 若以「邊數」為單位：
    - 根節點的**深度** = 0
    - 葉節點的**高度** = 0

- 若以「節點數」為單位（LeetCode 常用）：
    - 根節點的**深度** = 1
    - 葉節點的**高度** = 1

## 📗 二、LeetCode 定義與使用（偏向節點數）

| 問題類型            | 方法            | 對應概念    | 定義方式    |
|-----------------|---------------|---------|---------|
| `Maximum Depth` | `root` 的高度    | 整棵樹最大深度 | 回傳節點數   |
| `Balanced Tree` | 每個節點左右高度差 ≤ 1 | 使用節點高度  | 用遞迴後序遍歷 |
| `Diameter`      | 最長路徑邊數        | 與高度有關   | 回傳邊數    |

- LeetCode 通常把「深度」視為節點數，而不是邊數。
- Maximum Depth of Binary Tree（#104）回傳的是根節點的高度（以節點數計）。
- Balanced Binary Tree（#110）須對每個節點判斷 |leftHeight - rightHeight| <= 1。

## 🌳 三、圖示說明：深度與高度對比（以節點數為單位）

```
高度  深度  
 3     1         A
               / | \
 2     2      B  C  D
                 |
 1     3         E
```
- `E` 的深度是 3（A → C → E，共 3 個節點）
- `A` 的高度是 3（最遠子節點為 E，共 3 個節點）
  整棵樹的最大深度 = `A` 的高度 = 3

## 🧠 四、遍歷方式選擇與對應

| 目標   | 遍歷策略 | 遞迴方向  | 使用函式       |
|------|------|-------|------------|
| 求深度  | 前序   | 根 → 葉 | 往下遞迴       |
| 求高度  | 後序   | 葉 → 根 | 回傳 +1 往上累加 |
| 是否平衡 | 後序   | 葉 → 根 | 需要知道左右高度   |

---

# LC110. Balanced Binary Tree

## 題目說明
- 給定一棵二元樹，判斷其是否為「高度平衡」的樹。
- 高度平衡定義：每個節點的左右子樹高度差不得超過 1。

--- 

## 解法一：DFS 後序遞迴 + 高度剪枝

### 思路
- 採後序遞迴，先計算左右子樹高度。
- 若發現任一子樹已不平衡（回傳 -1），立即終止遞迴。
- 否則回傳節點的高度（左右最大 + 1）。

### 重點
- 後序遍歷是關鍵（需先知道左右子樹的高度）
- 高度差 > 1 就剪枝回傳 -1

### 複雜度分析
- Time: O(n)，每個節點最多訪問一次
- Space: O(h)，遞迴深度為樹高，最壞為 O(n)

--- 

## Java 程式碼連結
- 題目實作：[ID110BalancedBinaryTree.java](../../src/main/java/io/github/monty/leetcode/binarytree/ID110BalancedBinaryTree.java)
- 單元測試：[ID110BalancedBinaryTreeTest.java](../../src/test/java/io/github/monty/leetcode/binarytree/ID110BalancedBinaryTreeTest.java)

---

# LC257. Binary Tree Paths

## 題目說明
- 給定一個二元樹，請找出所有從根節點到葉節點的路徑。
- 每條路徑需以 `->` 連接節點數值，並以字串表示。
  - 例如： 
  - 輸入：[1,2,3,null,5]
  - 輸出：["1->2->5","1->3"]

---

## 解法一：DFS 遞迴（使用 StringBuilder + 回溯）

### 思路
- 使用前序遍歷方式（根 -> 左 -> 右）遍歷整棵樹。
- 每次遇到節點就將其值加入路徑字串中，若為葉節點就將整條路徑加入結果。
- 使用 `StringBuilder` 優化字串拼接效能，並使用回溯方式避免記憶體污染。

### 重點
- 葉節點定義為左右子節點皆為 null 的節點。
- `StringBuilder` 共用記憶體空間並還原狀態 (`path.setLength(len)`) 是效能優化關鍵。

#### String vs StringBuilder 解法比較

| 方法                   | 空間複雜度  | 優點       | 缺點             |
|----------------------|--------|----------|----------------|
| String 相加            | O(n^2) | 寫法直觀     | 每次都建立新字串，浪費記憶體 |
| StringBuilder + 回溯 ✅ | O(h)   | 效能佳、記憶體低 | 稍需掌握回溯邏輯       |

### 複雜度分析
- 時間複雜度：O(n)，每個節點拜訪一次。
- 空間複雜度：O(h)，h 為樹的高度，為遞迴棧深度。



## Java 程式碼連結
- 題目實作：[ID257BinaryTreePaths.java](../../src/main/java/io/github/monty/leetcode/binarytree/ID257BinaryTreePaths.java)
- 單元測試：[ID257BinaryTreePathsTest.java](../../src/test/java/io/github/monty/leetcode/binarytree/ID257BinaryTreePathsTest.java)
