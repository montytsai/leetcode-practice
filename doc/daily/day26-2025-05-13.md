# LeetCode 60 天挑戰 Day26 | Binary Tree Part V

# 今日任務

- LC106. Construct Binary Tree from Inorder and Postorder Traversal
- LC105. Construct Binary Tree from Preorder and Inorder Traversal

---

# LC106. Construct Binary Tree from Inorder and Postorder Traversal

## 題目說明
給定一個沒有重複數字的二元樹的中序遍歷（`inorder`）與後序遍歷（`postorder`），請根據這兩種遍歷方式重建這棵二元樹。

--- 

## 解法：遞迴（配合 Map 優化查找）

### 思路
1. **後序遍歷最後一個元素為 root**。
2. **根據 root 在中序遍歷的位置劃分左右子樹長度**。
3. 依據左右子樹長度，從後序遍歷中切出對應的左右子樹區間，再遞迴構建左右子樹。

### 重點

#### 1. 利用 index 控制子樹區間，避免建立子陣列（節省記憶體）。

- 使用 index 控制區間，避免額外建立子陣列 → **節省記憶體使用與分配成本**。   
- 對於 LeetCode 大量遞迴呼叫而言，記憶體分配與 GC 開銷會明顯影響效能。

> 延伸❓為何使用 array 而不是 List 的 `subList()`？
> - Array 區間處理是 LeetCode 常見高效技巧，避免使用 `List.subList()` 是實戰經驗的累積。

#### 2. 利用 `Map<Integer, Integer>` 儲存中序遍歷中值對應的索引，加速搜尋 root 的位置（從 O(n) 降到 O(1)）。

- map v.s for-loop

| 方法                      | 複雜度                      | 效率                  |
|-------------------------|--------------------------|---------------------|  
| `Map<Integer, Integer>` | 查找 index 為 O(1)，整體為 O(n) | 快速                  |  
| `for loop` 每次尋找         | 單次 O(n)，總體可能為 O(n²)      | 緩慢，尤其對於 skewed tree |  

> 延伸❓使用 Map 而非 for-loop 查找 root index？
> - 自問：「每次都要 `for` 找 root index？有更快方法嗎？」
> - 想到用 hash map 儲存中序值與索引對應（與 Two Sum 類似技巧）

### 複雜度分析
- 時間複雜度：`O(n)`，每個節點處理一次 + map 查找為 O(1)
- 空間複雜度：`O(n)`，map 儲存 n 個元素 + 遞迴堆疊最深為 n

---

## Java 程式碼連結

- 題目實作：[ID106ConstructBinaryTreeFromInorderAndPostorderTraversal.java](../../src/main/java/io/github/monty/leetcode/binarytree/ID106ConstructBinaryTreeFromInorderAndPostorderTraversal.java)
- 單元測試：[ID106ConstructBinaryTreeFromInorderAndPostorderTraversalTest.java](../../src/test/java/io/github/monty/leetcode/binarytree/ID106ConstructBinaryTreeFromInorderAndPostorderTraversalTest.java)

---

# LC105. Construct Binary Tree from Preorder and Inorder Traversal

## 題目說明
給定一個二元樹的前序遍歷（preorder）與中序遍歷（inorder）結果，還原這棵樹。

---

## 解法一：Divide and Conquer（遞迴）

### 思路
- 邏輯同 LC106
- 前序遍歷的第一個元素永遠是當前子樹的根節點。
- 根據該值在中序遍歷中的 index，可以知道左子樹與右子樹的大小與位置。
- 遞迴對左右子樹進行相同處理即可。

### 重點
- 使用 HashMap 儲存中序值與 index 的對應，以加速查找。
- 子樹分界不需實際切 array，只需傳入索引範圍即可避免額外記憶體開銷。
- 遞迴方式，若遇到極端情況（如單邊樹），需留意 stack overflow。

### 複雜度分析
- 時間複雜度：O(n)，每個節點只處理一次。
- 空間複雜度：O(n)，HashMap 及遞迴堆疊空間。

--- 

## Java 程式碼連結
- 題目實作：[ID105ConstructBinaryTreeFromPreorderAndInorderTraversal.java](../../src/main/java/io/github/monty/leetcode/binarytree/ID105ConstructBinaryTreeFromPreorderAndInorderTraversal.java)
- 單元測試：[ID105ConstructBinaryTreeFromPreorderAndInorderTraversalTest.java](../../src/test/java/io/github/monty/leetcode/binarytree/ID105ConstructBinaryTreeFromPreorderAndInorderTraversalTest.java)

